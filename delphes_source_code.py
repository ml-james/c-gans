# Script that generates the training data for Delphes, adapted from the source
# code included in Appendix B.

import random
import math
import numpy as np
import h5py
import matplotlib.pyplot as plt

# Pythia electron gun

# Various distributions generated by "Pythia"


def Real_Log(p_max, eta_max, events):

    number_of_instances = 10000
    g_range = range(number_of_instances)
    events_array = np.zeros([number_of_instances, events, 3])

    for i in g_range:

        for j in range(events):

            pp = math.pow(10, (-1.0 + (np.log10(p_max) + 1.0) * random.uniform(0, 1)))
            eta = ((2.0 * random.uniform(0, 1)) - 1) * eta_max
            phi = 2.0 * np.pi * random.uniform(0, 1)
            pt = pp / np.cosh(eta)

            events_array[i, j, 0] = pt
            events_array[i, j, 1] = eta
            events_array[i, j, 2] = phi

    return events_array


def Real_Spike(p, eta, phi, events):

    number_of_instances = 300
    g_range = range(number_of_instances)
    events_array = np.zeros([number_of_instances, events, 3])

    for i in g_range:

        for j in range(events):

            pp = p
            eta = eta
            phi = phi
            pt = pp / np.cosh(eta)

            events_array[i, j, 0] = pt
            events_array[i, j, 1] = eta
            events_array[i, j, 2] = phi

    return events_array


def Real_Random(p_max, eta_max, phi, events):

    number_of_instances = 10000

    events_array = np.zeros([number_of_instances, events, 3])
    for i in range(number_of_instances):
        for j in range(events):
            pp = p_max * np.random.uniform(0, 1)
            eta = ((2.0 * random.uniform(0, 1)) - 1) * eta_max
            phi = 2.0 * np.pi * random.uniform(0, 1)
            pt = pp / np.cosh(eta)

            events_array[i, j, 0] = pt
            events_array[i, j, 1] = eta
            events_array[i, j, 2] = phi

    return events_array


# Real = Real_Log(5,2.5,1024)
# Real_ = Real_Spike(5,2.5,3.14,1024)
# _Real = Real_Random(20,2.5,6.28,1024)

# Plot

# bins = np.linspace(0,5,100)
# plt.hist(Real[0][:,0],bins,histtype='step',color='red',label='first_sample')
# plt.hist(Real[1][:,0],bins,histtype='step',color='blue',label='second_sample')
# plt.title("Transverse Momentum Distribution of Electrons \n Fired from an Electron Gun")
# plt.xlabel("Momentum / GeV")
# plt.ylabel("Number")
# plt.legend(loc='upper right')

# Tracking efficiency


def Tracking_Efficiency_Electron(events_array):

    g_range = range(events_array.shape[0])

    output_ = np.zeros(
        (events_array.shape[0], events_array.shape[1], events_array.shape[2])
    )

    for i in g_range:
        for j in range(events_array.shape[1]):
            if abs(events_array[i][j][0]) <= 0.1:
                output_[i][j][0] = 0.0
                output_[i][j][1] = 0.0
                output_[i][j][2] = 0.0
            if (
                abs(events_array[i][j][0]) <= 1.5
                and abs(events_array[i][j][0]) > 0.1
                and abs(events_array[i][j][0]) <= 1.0
            ):
                a = np.random.randint(0, 1)
                if a < 0.73:
                    output_[i][j][0] = events_array[i][j][0]
                    output_[i][j][1] = events_array[i][j][1]
                    output_[i][j][2] = events_array[i][j][2]
                else:
                    output_[i][j][0] = 0.0
                    output_[i][j][1] = 0.0
                    output_[i][j][2] = 0.0
            if (
                abs(events_array[i][j][1]) <= 1.5
                and abs(events_array[i][j][0]) > 0.1
                and abs(events_array[i][j][0]) <= 10
            ):
                a = np.random.randint(0, 1)
                if a < 0.95:
                    output_[i][j][0] = events_array[i][j][0]
                    output_[i][j][1] = events_array[i][j][1]
                    output_[i][j][2] = events_array[i][j][2]
                else:
                    output_[i][j][0] = 0.0
                    output_[i][j][1] = 0.0
                    output_[i][j][2] = 0.0
            if abs(events_array[i][j][1]) <= 1.5 and abs(events_array[i][j][0]) > 10:
                a = np.random.randint(0, 1)
                if a < 0.99:
                    output_[i][j][0] = events_array[i][j][0]
                    output_[i][j][1] = events_array[i][j][1]
                    output_[i][j][2] = events_array[i][j][2]
                else:
                    output_[i][j][0] = 0.0
                    output_[i][j][1] = 0.0
                    output_[i][j][2] = 0.0
            if (
                abs(events_array[i][j][1]) > 1.5
                and abs(events_array[i][j][1]) <= 2.5
                and abs(events_array[i][j][0]) > 0.1
                and abs(events_array[i][j][0]) <= 1.0
            ):
                a = np.random.randint(0, 1)
                if a < 0.50:
                    output_[i][j][0] = events_array[i][j][0]
                    output_[i][j][1] = events_array[i][j][1]
                    output_[i][j][2] = events_array[i][j][2]
                else:
                    output_[i][j][0] = 0.0
                    output_[i][j][1] = 0.0
                    output_[i][j][2] = 0.0
            if (
                abs(events_array[i][j][1]) > 1.5
                and abs(events_array[i][j][1]) <= 2.5
                and abs(events_array[i][j][0]) > 0.1
                and abs(events_array[i][j][0]) <= 10
            ):
                a = np.random.randint(0, 1)
                if a < 0.83:
                    output_[i][j][0] = events_array[i][j][0]
                    output_[i][j][1] = events_array[i][j][1]
                    output_[i][j][2] = events_array[i][j][2]
                else:
                    output_[i][j][0] = 0.0
                    output_[i][j][1] = 0.0
                    output_[i][j][2] = 0.0
            if (
                abs(events_array[i][j][1]) > 1.5
                and abs(events_array[i][j][1]) <= 2.5
                and abs(events_array[i][j][0]) > 10
            ):
                a = np.random.randint(0, 1)
                if a < 0.90:
                    output_[i][j][0] = events_array[i][j][0]
                    output_[i][j][1] = events_array[i][j][1]
                    output_[i][j][2] = events_array[i][j][2]
                else:
                    output_[i][j][0] = 0.0
                    output_[i][j][1] = 0.0
                    output_[i][j][2] = 0.0

            if abs(events_array[i][j][1]) > 2.5:
                output_[i][j][0] = 0.0
                output_[i][j][1] = 0.0
                output_[i][j][2] = 0.0

    return output_


# Delphes momentum resolution


def Resolution(input_):

    g_range = range(input_.shape[0])

    res = np.zeros((input_.shape[0], input_.shape[1], input_.shape[2]))

    for i in g_range:
        for j in range(input_.shape[1]):
            if abs(input_[i][j][1]) <= 0.5 and input_[i][j][0] > 0.1:
                res_ = (
                    abs(input_[i][j][0])
                    * abs(input_[i][j][1])
                    * math.sqrt(
                        0.03 * 0.03
                        + (input_[i][j][0] * input_[i][j][0] * (1.30e-3) * (1.30e-3))
                    )
                )
            if (
                abs(input_[i][j][1]) > 0.5
                and abs(input_[i][j][1]) <= 1.5
                and input_[i][j][0] > 0.1
            ):
                res_ = (
                    abs(input_[i][j][0])
                    * abs(input_[i][j][1])
                    * math.sqrt(
                        0.05 * 0.05
                        + (input_[i][j][0] * input_[i][j][0] * (1.70e-3) * (1.70e-3))
                    )
                )
            if (
                abs(input_[i][j][1]) > 1.5
                and abs(input_[i][j][1]) <= 2.5
                and input_[i][j][0] > 0.1
            ):
                res_ = (
                    abs(input_[i][j][0])
                    * abs(input_[i][j][1])
                    * math.sqrt(
                        0.15 * 0.15
                        + (input_[i][j][0] * input_[i][j][0] * (3.10e-3) * (3.10e-3))
                    )
                )
            if abs(input_[i][j][0]) <= 0.1:
                res_ = 0
            res[i, j, 0] = res_
            res[i, j, 1] = input_[i, j, 1]
            res[i, j, 2] = input_[i, j, 2]
    return res


# Delphes resolution trimming


def Resolution_Trimming(input_):

    g_range = range(input_.shape[0])

    Res = np.zeros((input_.shape[0], input_.shape[1], input_.shape[2]))

    for i in g_range:
        for j in range(input_.shape[1]):
            if input_[i][j][0] > 1.0:
                Res[i][j][0] = 1.0
            else:
                Res[i][j][0] = input_[i][j][0]
            Res[i][j][1] = input_[i][j][1]
            Res[i][j][2] = input_[i][j][2]
    return Res


# Res_Out = Resolution(Real,verbose=False)
# Res_Out1 = Resolution_Trimming(Res_Out,verbose=False)
# Smear_Input = Res_Out1

# Plot

# bins = np.linspace(0,1,100)
# plt.hist(Res_Out1[0][:,0],bins,histtype='step',color='red',label='first_sample')
# plt.hist(Res_Out1[1][:,0],bins,histtype='step',color='blue',label='second_sample')
# plt.title("Momentum Resolution")
# plt.xlabel("Resolution")
# plt.ylabel("Number")
# plt.legend(loc='upper right')

# Delphes momentum smearing


def Momentum_Smearing_Log_Normal(mean, sigma):
    if mean > 0:
        b = math.sqrt(np.log((1.0 + (sigma * sigma) / (mean * mean))))
        a = np.log(mean) - 0.5 * b * b
        return np.exp(a + b * np.random.normal(0.0, 1.0))
    else:
        return 0.0


def Momentum_Smearing_Gauss(mean, sigma):
    return np.random.normal(mean, sigma)


def Smear(input_, resolution):

    g_range = range(input_.shape[0])

    Smear = np.zeros((input_.shape[0], input_.shape[1], input_.shape[2]))

    for i in g_range:
        for j in range(input_.shape[1]):
            Smear[i][j][0] = Momentum_Smearing_Log_Normal(
                input_[i][j][0], resolution[i][j][0] * input_[i][j][0]
            )
            Smear[i][j][1] = input_[i][j][1]
            Smear[i][j][2] = input_[i][j][2]
    return Smear


# Fake = Smear(Real,Smear_Input,verbose=False)

# Plot the pT, eta and phi variations in training data and training labels

# bins = np.linspace(0,5,100)
# plt.hist(Real[1][:,0],bins,histtype='step',color='red',label='real')
# plt.hist(Fake[1][:,0],bins,histtype='step',color='blue',label='delphes')
# plt.title("Transverse Momentum Distribution of \n Electrons Fired from an Electron Gun")
# plt.xlabel("Momentum / GeV")
# plt.ylabel("Number")
# plt.legend(loc='upper right')
# plt.show()

# bins = np.linspace(0,2.5,100)
# plt.hist(Real[1][:,1],bins,histtype='step',color='red',label='real')
# plt.hist(Fake[1][:,1],bins,histtype='step',color='blue',label='delphes')
# plt.title("Eta Distribution of \n Electrons Fired from an Electron Gun")
# plt.xlabel("Eta / radians")
# plt.ylabel("Number")
# plt.legend(loc='upper right')
# plt.show()

# bins = np.linspace(0,6.3,100)
# plt.hist(Real[1][:,2],bins,histtype='step',color='red',label='real')
# plt.hist(Fake[1][:,2],bins,histtype='step',color='blue',label='delphes')
# plt.title("Phi Distribution of \n Electrons Fired from an Electron Gun")
# plt.xlabel("Phi / radians")
# plt.ylabel("Number")
# plt.legend(loc='upper right')
# plt.show()

# Runs functions above to automise data collection

# For generating log distribution


def Run_Entire_Log():

    Real = Real_Log(20, 2.5, 512)
    Fake = Smear(Real, Resolution_Trimming(Resolution(Real)))

    return Real, Fake


# For generating data at a particular point, e.g. for Dataset A


def Run_Entire_Spike():

    p = [10]
    eta = [1.5]
    phi = [2.5]

    Real_ = np.zeros((1, 300, 512, 3))
    Fake_ = np.zeros((1, 300, 512, 3))

    g_range = range(len(p))

    l = -1
    for i in g_range:
        for j in range(len(eta)):
            for k in range(len(phi)):
                l = l + 1
                Real_[l] = Real_Spike(p[i], eta[j], phi[k], 512)
                Fake_[l] = Smear(
                    Real_[l],
                    Resolution_Trimming(
                        Resolution(Tracking_Efficiency_Electron(Real_[l]))
                    ),
                )

    return Real_, Fake_


# For generating data randomly but uniformly, e.g. for Dataset B


def Run_Entire_Random():

    Real = Real_Random(20, 2.5, 6.28, 1024)
    Fake = Smear(
        Real, Resolution_Trimming(Resolution(Tracking_Efficiency_Electron(Real)))
    )

    return Real, Fake


# Pythia = training labels, Delphes = training images

Pythia, Delphes = Run_Entire_Random()
Pythia_ = Pythia
Delphes_ = Delphes

# We will need to shuffle the data, but in a predictable way so the labels do
# not get mismatched

RND = 777
np.random.seed(RND)

index = np.random.choice(len(Pythia_), len(Pythia_), replace=False)

# Now this is our training data

X_Train = Delphes_[index]
Y_Train = Pythia_[index]

# Saving training data

h5f = h5py.File("...Delphes.h5", "w")
h5f.create_dataset("Training_Data", data=X_Train)
h5f.create_dataset("Training_Labels", data=Y_Train)
h5f.close()

# Load dataset and plot to check

h5f = h5py.File("...Delphes.h5", "r")
a = h5f["Training_Data"][:]
b = h5f["Training_Labels"][:]
h5f.close()


def plot(event1, event2, event3):

    bins = np.linspace(
        min(a[event1, event2, :, event3]), max(a[event1, 0, :, event3]), 50
    )
    plt.hist(
        a[event1, event2, :, event3],
        bins,
        histtype="step",
        color="green",
        label="delphes",
    )
    plt.title(
        "Transverse Momentum Distribution of \n Electrons Fired from an Electron Gun"
    )
    plt.xlabel("Momentum / GeV")
    plt.ylabel("Number")
    plt.legend(loc="upper right")
    plt.show()
    print(b[event1, 0, 0, :])


plot(0, 0, 0)
